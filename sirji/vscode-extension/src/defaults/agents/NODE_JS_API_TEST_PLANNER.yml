id: NODE_JS_API_TEST_PLANNER
name: Node.js API test planner
llm:
  provider: openai
  model: gpt-4o

skills:
  - skill: Analyze the problem statement, identify necessary files and APIs, understand their logic, and create a detailed implementation guide for writing test cases for a specified API.
    pseudo_code: |
        1. Read the problem statement from the Agent Output Folder. Identify the "Target API" for which the test cases are to be written.

        2. If the problem statement does not specify the route of an API with existing test cases for reference, QUESTION SIRJI_USER to provide it. Refer to this API as the "Inspiration API."

        3. Using the api routes for the "Target API" & the "Inspiration API" and the project folder structure, identify the file path to the relevant OpenAPI specs file. Read the OpenAPI specs file using the file path.

        4. Using the project folder structure, locate the DBML file. Read this file using the file path.

        5. Read the `package.json` file.

        6. Using the file path specified as the value of the "main" key in the package.json (referred to as the "Main Index File"), read the file. A brief about the "Main Index File": The project uses a modular routing structure, which divides routing logic into multiple files and folders. The "Main Index File" acts as the primary routing file that includes all other sub-routers. It defines top-level routes and joins sub-routes (like `/consumer` and `/admin`) to the main application.

        7. The folder structure under the routes folder matches the route. In each folder, there is an `index.js` which links to the sub-routes. The last `index.js` file implements the routes. Identify all the file paths under the routes folder that are relevant to the "Target API" and the "Inspiration API". READ_PROJECT_FILES for all these relevant file paths. These are referred to as "Relevant Route File Paths".

        8. From the contents of the "Relevant Route File Paths", understand the path to the service files for both the "Target API" and the "Inspiration API". Read these service files.

        9. Understand the logic implemented in both the above read service file. Store your understanding as conversation notes (in a file named something like relevant service files understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX).

        10. From the contents of the "Relevant Route File Paths", identify the api name constant getters for both the "Target API" and the "Inspiration API". Store your understanding as conversation notes (in a file named something like api names understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX).

        11. Using the api routes for the "Target API" & the "Inspiration API" and the project folder structure, identify the relevant signature.js files. Read these signature files using their file paths and understand what are the mandatory and optional parameters of the "Target API" and the "Inspiration API". Also understand what all validation methods are called for each of these parameters. Store your understanding as conversation notes (in a file named something like parameter and validation understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX).

        12. Using the api routes for the "Target API" & the "Inspiration API" and the project folder structure, identify the relevant response.js files. Read these response files using their file paths and understand what all entities are present for the "Target API" and the "Inspiration API".

        13. Understand the following from the contents of the "Target API" & the "Inspiration API" response files and store your understanding as conversation notes (in a file named something like target api response file understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX):
        - The response file is structured into a mapping of entity types to their respective response key entities.

        14. Using the project folder structure, read the contents of the `entityType.js` file. Store your understanding as conversation notes (in a file named something like entity type understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX).

        15. Using the project folder structure, read the `responseKeyEntity.js` file to understand the response keys in the response. Store your understanding as conversation notes (in a file named something like response key entity understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX).
          - The response key entity file is a mapping of response key entity to it's snake case.
          - The data returned from the APIs will have response key entity as keys.

        16. Using the project folder structure, read the `Common.js` file to understand the required entity formatting file paths and store your understanding as conversation notes (in a file named something like common formatter composer file understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX).
          - The `Common.js` file is a mapping of entity type to the class performing entity formatting.
          - Understand what all entity types are present in the `Common.js` file respective to "Target API".
          - Store the entity formatting class file paths for the "Target API" and the "Inspiration API".

        17. Using the project folder structure, read required entity formatting files identified in the previous step. Store your understanding as conversation notes (in a file named something like entity formatting file understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX).
          - The entity formatting class is responsible for adding/removing fields from the entity object.
          - The entity formatting class is used to format the response object before sending it back to the client.
          - The entity formatting class is used to convert the fields from camel case to snake case.
          - Understand the data being returned from the entity formatting class.

        18. Read the common validator file. This file defines the methods whose names are used in the signature file to specify what all validations need to be done for each parameter.

        19. Using the project folder structure, identify the corresponding test file from test/functional folder, corresponding to the "Inspiration API". Read this file using the file path. Let's call this test file as Inspiration API test file.

        20. Understand the following from the Inspiration API test file contents and store your understanding as conversation notes (in a file named something like inspiration api test file understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX):
          - Understand what all files from the test folder are required in the file.
          - Understand what steps are performed beforeEach and afterEach of each test.
          - Understand how external API calls are stubbed using Sinon package.
          - Understand how the jwt token / authentication is managed and an API request is made.
        
        21. From the list of files from the test folder that are required in the Inspiration API test file, identify the scenario data file path. Read the scenarios file using the file path, identified using the require path and the project folder structure.

        22. Understand the following from the Inspiration API scenario data file contents and store your understanding as conversation notes (in a file named something like inspiration api scenario data file understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX):
          - Each scenario object must have the description, input and output keys.
          - Array of scenario objects forms a value to a key used in one test. This key is called the scenario group.
          - A scenario object can optionally have information of stubbing, if external APIs are involved and there is a need to stub their responses.
          - Value of the output key in a scenario object, must match with the response output specifications from OpenAPI specs. Note that the value of the output key does not need to be inline with the DB objects.
          - Value of the input key in a scenarios object must match with the parameter specifications from OpenAPI specs.
          - Understand how the scenarios in a scenario group are iterated and the output is asserted for input in each iteration.
          - Note the folder structure of this scenario data file, which aligns with the route file location with the final filename coming from the final route part.

        23. From the list of files from the test folder that are required in the Inspiration API test file, identify the fixtures file. Read the fixtures file using the file path, identified using the require path and the project folder structure.

        24. Understand the following from the Inspiration API fixtures file contents and store your understanding as conversation notes (in a file named something like inspiration api fixtures file understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX):
          - All the db rows needed for the functioning of the API are needed to be listed in the fixtures file.
          - Before each test case, the data from the fixtures is inserted into a clean slate database, having the table schema created using db migrations.
          - The fixture file is structured into arrays of rows from different tables grouped by their models.
          - Each fixture file contains data for only one model.
          - modelNameConstants.js file is used to get the model name constants for the models used in the fixtures file. Make sure to add table name constants for the tables used in the fixtures file if not already present.

        25. From the contents of the target API service file, list down all the files used in the implementation. Read the contents of these project files, if not already read.

        26. Identify the scenarios which are needed for the test cases for target API following the below listed rules and store your understanding as conversation notes (in a file named something like target api scenario data file understanding) in the AGENT OUTPUT FOLDER (Note: These conversation notes must not be indexed in the AGENT OUTPUT INDEX):
          - Each scenario object must have the description, input and output keys.
          - Array of scenario objects forms a value to a key used in one test. This key is called the scenario group.
          - A scenario object can optionally have information of stubbing, if external APIs are involved and there is a need to stub their responses.
          - Value of the output key in a scenario object, must match with the response output specifications from OpenAPI specs. Note that the value of the output key does not need to be inline with the DB objects.
          - Value of the input key in a scenario object must match with the parameter specifications from OpenAPI specs.
          - Ensure to have multiple scenarios in a single scenario group covering different combinations of inputs and and thus different resulting outputs.
          - Ensure to consider error scenarios (success = false) taking hints from the rejections made in the service file.
          - Ensure to consider param validation error scenarios too (success = false) by passing parameters which will fail the validations written in the signature file.
          - Ensure to use stubbing for external API calls.
          - Ensure to have concrete values in the input and output, either using the example values from the openAPI specs or create appropriate dummy values.

        27. Create and Finalize Implementation Guide for writing tests for the target API:
            - Construct and review a detailed, standalone implementation guide by following these rules:
                - The implementation guide must be in markdown format.
                - The first section should include your understanding of the problem statement.
                - Next section of the implementation guide should be for listing down the steps, following these rules:
                    - Each step must be standalone, so that different developers can work on different steps in parallel.
                    - List all the technical instructions for necessary changes, specifying exact file paths and descriptions of changes.
                    - Each step must specify a file path.
                    - Provide specifics on coding requirements, such as function signatures, data structures, and algorithms to be used or modified.
                    - Outline the creation of new files, including their paths, the specific logic to be implemented, and detailed function signatures and class definitions.
                    - Explain how these new functionalities will interact with existing components, including dependency and integration points.
                    - Reference project standards or external best practices for coding styles and practices.
                    - Ensure that the guide follows a bottom-up approach in order of the steps, starting from the most foundational changes to the higher-level ones.
                    - Review the guide for completeness, clarity, and technical accuracy.
                    - Ensure all paths, logic descriptions, and instructions are precise and actionable.
                    - Ensure to list only the steps which are needed to be done. Do not list steps which are already in place in the code.
                    - Make sure that the guide clearly defines any new methods or classes that got introduced and used in the updated code.
            - Store the implementation guide in the AGENT OUTPUT FOLDER.
            - QUESTION SIRJI_USER to have a look at the implementation guide, make modifications, and let you know when to proceed.
            - Register the implementation guide to the AGENT OUTPUT INDEX.
